import os
import hashlib
import requests
import csv
import sys
import time
import sqlite3
import math

# VirusTotal API Key
virusTotal_key = "98e3065f8941b7dcd82382650fe7114b203582629bc71029a3a32e69f5826ff4"
database_name = "file_hashes.db"

# Initialize the SQLite database and create necessary tables
def init_db():
    conn = sqlite3.connect(database_name)
    c = conn.cursor()
    
    # file hashes
    c.execute('''
        CREATE TABLE IF NOT EXISTS file_hashes (
            filename TEXT PRIMARY KEY,
            hash TEXT NOT NULL,
            timestamp TEXT NOT NULL
        )
    ''')

    # VirusTotal scan results
    c.execute('''
        CREATE TABLE IF NOT EXISTS virus_scan_results (
            hash TEXT PRIMARY KEY,
            permalink TEXT,
            positives INTEGER,
            total INTEGER,
            timestamp TEXT
        )
    ''')
    
    conn.commit()
    conn.close()

def calculate_entropy(file_path):
    """Calculate entropy to detect if a file is packed or obfuscated."""
    with open(file_path, 'rb') as f:
        data = f.read()
        if not data:
            return 0
        entropy=0
        byte_count = len(data)
        freq = {}
        for byte in data:
            freq[byte] = freq.get(byte, 0) + 1
        for count in freq.values():
            p = count / byte_count
            entropy -= p * math.log2(p)
        return entropy
    
def check_file_anomaly(file_path):
    """Check file metadata and entropy for anomalies."""
    file_stat = os.stat(file_path)
    entropy = calculate_entropy(file_path)
    
    # Example thresholds for entropy, modify as needed
    if entropy > 7.5:
        print(f"Warning: High entropy detected in {file_path}. This could indicate obfuscation or malware.")
    else:
        print(f"{file_path} entropy looks normal.")
    
    # Check for size or permission changes
    file_size = file_stat.st_size
    file_permissions = oct(file_stat.st_mode)[-3:]
    
    # Threshold checks (define your own thresholds for size, permissions, etc.)
    if file_size > 10**6:  # e.g., 1MB threshold for suspiciously large files
        print(f"Warning: {file_path} is larger than expected ({file_size} bytes).")
    if file_permissions != '644':
        print(f"Warning: {file_path} permissions are unusual ({file_permissions}).")
            

# Calculate the SHA256 hash of a file
def calculate_sha256(filename):
    sha256_hash = hashlib.sha256()
    with open(filename, "rb") as f:
        while True:
            data = f.read(65536)
            if not data:
                break
            sha256_hash.update(data)
    return sha256_hash.hexdigest()

# Check integrity of files in a directory and save the SHA256 hashes in the database
def check_integrity(directory_path):
    if not os.path.exists(directory_path) or not os.path.isdir(directory_path):
        print(f"Dossier {directory_path} n'existe pas")
        return

    conn = sqlite3.connect(database_name)
    c = conn.cursor()

    for root, dirs, files in os.walk(directory_path):
        for filename in files:
            file_path = os.path.join(root, filename)
            file_hash256 = calculate_sha256(file_path)
            print(f"Fichier: '{filename}' Hash: '{file_hash256}'")

            # Insert the hash into the database with a timestamp
            c.execute('''
                INSERT OR REPLACE INTO file_hashes (filename, hash, timestamp)
                VALUES (?, ?, ?)
            ''', (filename, file_hash256, time.ctime()))
    
    conn.commit()
    conn.close()

# Read hash values from a file, check them using VirusTotal, and store results in the database
def check_hashes(hashes_file):
    conn = sqlite3.connect(database_name)
    c = conn.cursor()

    with open(hashes_file, "r") as f:
        csvfile = csv.reader(f, delimiter="\n")
        pile = []
        for line in csvfile:
            print(f'Importation de {line} dans la pile')
            pile.append(line)
        
        while pile:
            hash_line = pile.pop()
            hash_line = ", ".join(str(e) for e in hash_line)
            
            c.execute("SELECT * FROM virus_scan_results WHERE hash=?", (hash_line,))
            existing_record = c.fetchone()

            if existing_record:
                print(f"Hash {hash_line} exist déja dans la database. Skipping VirusTotal scan.")
                print(f"Lien: {existing_record[1]}, Score: {existing_record[2]}/{existing_record[3]}")
            else:
                result = display_scan_result(hash_line)
                # Save the VirusTotal results in the database
                c.execute('''
                    INSERT OR REPLACE INTO virus_scan_results (hash, permalink, positives, total, timestamp)
                    VALUES (?, ?, ?, ?, ?)
                ''', (hash_line, result.get('permalink'), result.get('positives'), result.get('total'), time.ctime()))
    conn.commit()
    conn.close()

# Scan hash using VirusTotal API
def scan_hash(hash):
    url = 'https://www.virustotal.com/vtapi/v2/file/report'
    params = {
        'apikey': virusTotal_key,
        'resource': hash
    }
    response = requests.post(url, params=params)
    return response.json()

# Display scan results from VirusTotal
def display_scan_result(hash):
    result = scan_hash(hash)
    print(f"\nHash: {hash}")
    if len(sys.argv) > 2 and sys.argv[2] != hash:
        print(f"Fichier origin des hash: {sys.argv[2]}")
    if result.get('permalink') is not None:
        print(f"Lien: {result.get('permalink')}")
    score = result.get('positives')
    if score and int(score) > 0:
        print(f"\033[31mCe fichier est dangereux, Détecté par {score}/{result.get('total')} Antivirus\033[0m")
    else:
        print(f"\033[32mCe fichier est sécurisé\033[0m")
    return result


def main():
    init_db()  # Initialize the database before any operations

    if len(sys.argv) < 2 or sys.argv[1] == "--help":
        print("Usage: python script.py <option> <arguments>")
        print("Options:")
        print("  --check-integrity <directory>  : Calculate and save SHA256 hashes of files in a directory")
        print("  --scan-hash <hash_value>       : Scan a specific hash using VirusTotal API")
        print("  --check-hashes <hash_file>     : Scan hashes from a file and log results")
        print("  --scan-file <file_path>        : Scan a single file ")
        sys.exit(1)

    option = sys.argv[1]
    
    if option == "--check-integrity":
        if len(sys.argv) != 3:
            print("Usage: python script.py --check-integrity <directory>")
            sys.exit(1)
        directory = sys.argv[2]
        check_integrity(directory)

    elif option == "--scan-hash":
        if len(sys.argv) != 3:
            print("Usage: python script.py --scan-hash <hash_value>")
            sys.exit(1)
        hash_value = sys.argv[2]
        display_scan_result(hash_value)

    elif option == "--check-hashes":
        if len(sys.argv) != 3:
            print("Usage: python script.py --check-hashes <hash_file>")
            sys.exit(1)
        hash_file = sys.argv[2]
        check_hashes(hash_file)
    elif option =="--scan-file":
        if len(sys.argv)!=3:
            print("Usage: python script.py --scan-file <file_path>")
            sys.exit(1)
        file_toscan = sys.argv[2]
        check_file_anomaly(file_toscan)
    else:
        print("Invalid option. Use --help for available options.")
        sys.exit(1)

if __name__ == "__main__":
    main()
