import os
import hashlib
import requests
import csv
import sys
import time
import sqlite3
import math
from watchdog.observers import Observer # type: ignore
from watchdog.events import FileSystemEventHandler # type: ignore
from windows_toasts import Toast, WindowsToaster

# Clé API VirusTotal
virusTotal_key = "98e3065f8941b7dcd82382650fe7114b203582629bc71029a3a32e69f5826ff4"
database_name = "file_hashes.db"

# Initialiser la base de données SQLite et créer les tables nécessaires
def init_db():
    conn = sqlite3.connect(database_name)
    c = conn.cursor()

    # table des hashes de fichiers
    c.execute('''
        CREATE TABLE IF NOT EXISTS file_hashes (
            filename TEXT PRIMARY KEY,
            hash TEXT NOT NULL,
            timestamp TEXT NOT NULL
        )
    ''')

    # table des résultats de scan VirusTotal
    c.execute('''
        CREATE TABLE IF NOT EXISTS virus_scan_results (
            hash TEXT PRIMARY KEY,
            permalink TEXT,
            positives INTEGER,
            total INTEGER,
            timestamp TEXT
        )
    ''')

    conn.commit()
    conn.close()

def calculate_entropy(file_path):
    """Calculer l'entropie pour détecter si un fichier est compressé ou obfusqué."""
    with open(file_path, 'rb') as f:
        data = f.read()
        if not data:
            return 0
        entropy=0
        byte_count = len(data)
        freq = {}
        for byte in data:
            freq[byte] = freq.get(byte, 0) + 1
        for count in freq.values():
            p = count / byte_count
            entropy -= p * math.log2(p)
        return entropy
    
def check_file_anomaly(file_path):
    """Vérifier les métadonnées du fichier et l'entropie pour détecter des anomalies."""
    file_stat = os.stat(file_path)
    entropy = calculate_entropy(file_path)

    if entropy > 7.5:
        message=f"Avertissement : Entropie élevée détectée dans {file_path}. Cela pourrait indiquer une obfuscation ou un malware."
        display_notification(message)
    else:
        message=f"L'entropie du fichier {file_path} semble normale."
        display_notification(message)
        
    file_size = file_stat.st_size
    if file_size > 10**6:
        message=f"Avertissement : {file_path} est plus grand que prévu ({file_size} octets)."
        display_notification(message)

# Calculer le hash SHA256 d'un fichier
def calculate_sha256(filename):
    sha256_hash = hashlib.sha256()
    with open(filename, "rb") as f:
        while True:
            data = f.read(65536)
            if not data:
                break
            sha256_hash.update(data)
    return sha256_hash.hexdigest()

# Vérifier l'intégrité des fichiers dans un répertoire et enregistrer les hashes SHA256 dans la base de données
def check_integrity(directory_path):
    if not os.path.exists(directory_path) or not os.path.isdir(directory_path):
        print(f"Le dossier {directory_path} n'existe pas.")
        return

    conn = sqlite3.connect(database_name)
    c = conn.cursor()

    for root, dirs, files in os.walk(directory_path):
        for filename in files:
            file_path = os.path.join(root, filename)
            file_hash256 = calculate_sha256(file_path)
            print(f"Fichier : '{filename}' Hash : '{file_hash256}'")

            c.execute('''
                INSERT OR REPLACE INTO file_hashes (filename, hash, timestamp)
                VALUES (?, ?, ?)
            ''', (filename, file_hash256, time.ctime()))
    
    conn.commit()
    conn.close()

# Lire les valeurs de hash depuis un fichier, les vérifier via VirusTotal, et enregistrer les résultats dans la base de données
def check_hashes(hashes_file):
    conn = sqlite3.connect(database_name)
    c = conn.cursor()

    with open(hashes_file, "r") as f:
        csvfile = csv.reader(f, delimiter="\n")
        pile = []
        for line in csvfile:
            print(f'Importation de {line} dans la pile')
            pile.append(line)
        
        while pile:
            hash_line = pile.pop()
            hash_line = ", ".join(str(e) for e in hash_line)
            
            c.execute("SELECT * FROM virus_scan_results WHERE hash=?", (hash_line,))
            existing_record = c.fetchone()

            if existing_record:
                print(f"Le hash {hash_line} existe déjà dans la base de données. Scan VirusTotal ignoré.")
                print(f"Lien : {existing_record[1]}, Score : {existing_record[2]}/{existing_record[3]}")
            else:
                result = display_scan_result(hash_line)
                c.execute('''
                    INSERT OR REPLACE INTO virus_scan_results (hash, permalink, positives, total, timestamp)
                    VALUES (?, ?, ?, ?, ?)
                ''', (hash_line, result.get('permalink'), result.get('positives'), result.get('total'), time.ctime()))
    conn.commit()
    conn.close()

# Scanner le hash avec l'API VirusTotal
def scan_hash(hash):
    url = 'https://www.virustotal.com/vtapi/v2/file/report'
    params = {
        'apikey': virusTotal_key,
        'resource': hash
    }
    response = requests.post(url, params=params)
    return response.json()

# Afficher les résultats du scan VirusTotal
def display_scan_result(hash):
    result = scan_hash(hash)
    print(f"\nHash : {hash}")
    if len(sys.argv) > 2 and sys.argv[2] != hash:
        print(f"Fichier d'origine du hash : {sys.argv[2]}")
    if result.get('permalink') is not None:
        print(f"Lien : {result.get('permalink')}")
    score = result.get('positives')
    if score and int(score) > 0:
        print(f"\033[31mCe fichier est dangereux, détecté par {score}/{result.get('total')} antivirus\033[0m")
    else:
        print(f"\033[32mCe fichier est sécurisé\033[0m")
    return result

def display_notification(message):
    toaster = WindowsToaster('Surveillance')
    newToast = Toast()
    newToast.text_fields = [message]
    toaster.show_toast(newToast)
    
class DownloadHandler(FileSystemEventHandler):
    """Gérer les événements du système de fichiers pour le dossier de téléchargement."""

    def on_created(self, event):
        """Appelé lorsqu'un nouveau fichier est créé dans le répertoire surveillé."""
        if not event.is_directory:  # S'assurer qu'il s'agit d'un fichier
            check_file_anomaly(event.src_path)

def monitor_downloads_folder():
    """Configurer l'observateur Watchdog pour surveiller le dossier Téléchargements."""
    downloads_folder = os.path.expanduser("~/Downloads")
    
    event_handler = DownloadHandler()
    observer = Observer()
    observer.schedule(event_handler, downloads_folder, recursive=False)
    
    observer.start()
    
    try:
        while True:
            time.sleep(1)  # Garder le script en marche
    except KeyboardInterrupt:
        observer.stop()
    
    observer.join()

def main():
    init_db()

    if len(sys.argv) < 2 or sys.argv[1] == "--help":
        print("Utilisation : python script.py <option> <arguments>")
        print("Options :")
        print("  --check-integrity <répertoire> : Calculer et enregistrer les hashes SHA256 des fichiers d'un répertoire")
        print("  --scan-hash <valeur_hash>      : Scanner un hash spécifique avec l'API VirusTotal")
        print("  --check-hashes <fichier_hash>  : Scanner les hashes depuis un fichier et enregistrer les résultats")
        print("  --scan-file <chemin_fichier>   : Scanner un fichier unique")
        print("  --lancer-surveillance          : Activer la surveillance en temps réel des nouveaux fichiers téléchargés")
        sys.exit(1)

    option = sys.argv[1]
    
    if option == "--check-integrity":
        if len(sys.argv) != 3:
            print("Utilisation : python script.py --check-integrity <répertoire>")
            sys.exit(1)
        directory = sys.argv[2]
        check_integrity(directory)

    elif option == "--scan-hash":
        if len(sys.argv) != 3:
            print("Utilisation : python script.py --scan-hash <valeur_hash>")
            sys.exit(1)
        hash_value = sys.argv[2]
        display_scan_result(hash_value)

    elif option == "--check-hashes":
        if len(sys.argv) != 3:
            print("Utilisation : python script.py --check-hashes <fichier_hash>")
            sys.exit(1)
        hash_file = sys.argv[2]
        check_hashes(hash_file)

    elif option == "--scan-file":
        if len(sys.argv) != 3:
            print("Utilisation : python script.py --scan-file <chemin_fichier>")
            sys.exit(1)
        file_toscan = sys.argv[2]
        check_file_anomaly(file_toscan)
    elif option == "--lancer-surveillance":
        if len(sys.argv) !=2:
            print("Utilisation : python script.py --lancer-surveillance")
            sys.exit(1)
        monitor_downloads_folder()

    else:
        print("Option invalide. Utilisez --help pour les options disponibles.")
        sys.exit(1)

if __name__ == "__main__":
    main()
